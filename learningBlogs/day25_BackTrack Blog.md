
# Day25 算法训练营学习记录 - 回溯篇

第25天的学习的是子集问题、去重、排列问题等。

### 学习经验和教训：
    1）排列问题，相比组合、子集问题有所不同，区别如第二题所示；
    2）一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果。
    3）对于排列问题，树层去重和树枝去重，效果是一样的，但树层去重效率更高，避免了很多无用搜索。


    


---

### 第一题：递增子序列 

  对于养成思维定式或者套模板套嗨了的同学，这道题起到了很好的警醒作用。更重要的是拓展了大家的思路。

  这一题不能排序，所以去重逻辑跟之前有所不同；

  另外要求子序列是递增的，所以在不排序的基础上，如何在递归中，判断当前元素是否可以加入（满足递增条件）





---
### 第二题：全排列  
  
  大家此时可以感受出排列问题的不同：

  每层都是从0开始搜索而不是startIndex；
  需要used数组记录path里都放了哪些元素了；
  全排列的化，递归的时候，到达叶子节点即是可以收割的地方；
  排列问题是回溯算法解决的经典题目，大家可以好好体会体会。



---

### 第三题：全排列 II

  对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！

---

### 第四题：N皇后

N皇后这道题目还是很经典的

---

### 第五题：解数独

直接看了题解，了解了大体思路

二维递归

---

### 总结
  1）回溯是递归的副产品，只要有递归就会有回溯，所以回溯经常和二叉树遍历、深度优先搜索混在一起；

  2）回溯法是暴力搜索，不是什么高效的算法，最多减枝一下；

  3）主要解决组合问题、排列问题、切割问题、子集问题、棋盘问题；

  4）递归有三部曲，回溯也有三部曲，在涉及到其中问题时，按照三部曲模板去分析回溯算法；

  5）优化回溯算法只有剪枝一种方法：剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了；

  6）组合问题：for循环横向遍历，递归纵向遍历，回溯不断调整结果集；

  7）组合问题：如果是一个集合来求组合的话，就需要startIndex；如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex；

  8）去重:搞清楚“树枝去重”和“树层去重”,可以用vector<bool>, set, 数组去辅助去重；

  9）切割问题：用求解组合问题的思路来解决；另外如何模拟切割线，如何终止等

  10）子集问题:在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。

  11）排列问题：排列是有序的，处理排列问题就不用使用startIndex了，因为元素在每层中都是从0开始搜索，而不是startIndex;

  12）棋盘问题：将棋盘的搜索过程抽象为一颗树，二维矩阵的高就是这个树的高度，宽就是每个节点的宽度；只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了；

  13）棋盘问题：题解中明确给出了棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了。

  14）解数独问题：理解为“二维递归”的过程。其中N皇后问题 (opens new window)是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。解数独问题则是棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深；
  
  15）性能分析：

      子集问题分析：
        时间复杂度：O(2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)
        空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)

      排列问题分析：
        时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。
        空间复杂度：O(n)，和子集问题同理。

      组合问题分析：
        时间复杂度：O(2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
        空间复杂度：O(n)，和子集问题同理。

      N皇后问题分析：
        时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * .... * 1。
        空间复杂度：O(n)，和子集问题同理。

      解数独问题分析：
        时间复杂度：O(9^m) , m是'.'的数目。
        空间复杂度：O(n^2)，递归的深度是n^2

      一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！
  